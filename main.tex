% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  11pt,
  letterpaper,
]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Arial}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{setspace}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother


% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
  \begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
 % allow citations to break across lines
 \let\@cite@ofmt\@firstofone
 % avoid brackets around text for \cite:
 \def\@biblabel#1{}
 \def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
 {\begin{list}{}{%
  \setlength{\itemindent}{0pt}
  \setlength{\leftmargin}{0pt}
  \setlength{\parsep}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
   \setlength{\leftmargin}{\cslhangindent}
   \setlength{\itemindent}{-1\cslhangindent}
  \fi
  % set entry spacing
  \setlength{\itemsep}{#2\baselineskip}}}
 {\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}



\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\usepackage{indentfirst}  % Aplica sangría al primer párrafo
\setlength{\parindent}{1.5em}  % Tamaño de sangría
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\author{}
\date{}
\begin{document}


\setstretch{1.5}
\begin{titlepage}

\begin{centering}

\begin{Large}

\vspace*{3cm}

\textbf{Artículo - Patrones de diseño del software}

\vfill

\textbf{Presentado por:} \n Jeffry Varela Barrantes \n Carlos
Villafuerte Díaz \n Duvan Vásquez López

\vfill

\textbf{Universidad Cenfotec}

\includegraphics[width=4cm,height=\textheight,keepaspectratio]{img/image.png}

\vfill

\textbf{Fecha:} 30 de Julio de 2025

\vspace*{6cm}

\end{Large}

\end{centering}

\end{titlepage}

\section{Objetivo general y
específicos}\label{objetivo-general-y-especuxedficos}

\textbf{Objetivo General:} Comprender y comunicar conceptos
fundamentales del diseño de software, enfocándose en el análisis y
descripción de patrones, su propósito y su aplicación, como parte del
proceso de diseño orientado a la calidad del software.

\textbf{Objetivos Específicos:}

\begin{itemize}
\tightlist
\item
  Identificar y describir patrones de diseño comunes utilizados en el
  desarrollo de software.
\item
  Analizar el propósito, los beneficios y el contexto de uso de
  diferentes patrones de diseño.
\item
  Investigar y comunicar el estado del arte sobre patrones de diseño,
  utilizando fuentes actualizadas y confiables.
\item
  Estructurar un documento técnico claro y coherente, empleando
  herramientas como Quarto para su presentación formal.
\end{itemize}

\newpage

\section{Estado del arte}\label{estado-del-arte}

\subsection{Conceptos clave de patrones de
diseño}\label{conceptos-clave-de-patrones-de-diseuxf1o}

Los patrones de diseño de software son soluciones generales y
reutilizables para problemas comunes que ocurren en el proceso de diseño
de software. No son fragmentos de código listos para usar, sino pautas o
descripciones estructurales de una solución óptima, obtenidas por
experiencia acumulada. Por ejemplo, (Soler, 2024) los define como
``soluciones generales y reutilizables que se aplican a problemas
comunes en el diseño de software''. Estas soluciones estandarizadas
buscan promover la modularidad, la escalabilidad y el mantenimiento del
sistema. La aplicación de patrones ``ahorra tiempo y esfuerzo'' en el
desarrollo, facilita la comunicación entre desarrolladores (al disponer
de un lenguaje común) y contribuye a que el código sea más mantenible y
escalable. Los patrones se basan en principios de diseño (como SOLID) y
en la experiencia histórica de la ingeniería de software. Su uso
sistemático permite evitar reinventar la rueda, ya que ofrecen
estrategias que han sido comprobadas en múltiples proyectos. En palabras
de Refactoring.Guru, ``los patrones son un juego de herramientas que
brindan soluciones a problemas habituales en el diseño de software'' y
definen un lenguaje compartido que mejora la eficiencia comunicativa del
equipo. Sin embargo, es importante recordar que los patrones no son
algoritmos específicos, sino esquemas de solución que deben adaptarse al
contexto de cada proyecto.

Los patrones de diseño fueron popularizados por (Gamma et al., 1995),
quienes definieron 23 patrones clásicos en el contexto de la
programación orientada a objetos, agrupándolos en patrones creacionales,
estructurales y de comportamiento.

\subsection{Clasificación de patrones de
diseño}\label{clasificaciuxf3n-de-patrones-de-diseuxf1o}

La literatura coincide en clasificar los patrones de diseño en tres
categorías generales, según el problema que abordan:

\textbf{- Patrones creacionales:} Se enfocan en el proceso de creación
de objetos, encapsulando mecanismos de instanciación complejos.
Promueven la flexibilidad y la reutilización del código al ocultar la
lógica de creación. Ejemplos típicos son \textbf{\emph{Abstract Factory,
Builder y Singleton}}. Por ejemplo, (Soler, 2024) menciona que Abstract
Factory permite crear familias de objetos sin especificar las clases
concretas, mientras que Builder facilita la construcción de objetos
complejos paso a paso. El patrón Singleton garantiza que una clase tenga
una única instancia global, controlando su acceso. Estas técnicas ayudan
a desacoplar el código de cómo se crean sus objetos internos.

\textbf{-Patrones estructurales:} Definen cómo componer clases y objetos
para formar estructuras más grandes y eficaces. Buscan facilitar la
extensión y mantener la eficiencia al enlazar componentes. Ejemplos
conocidos son \textbf{\emph{Adapter, Facade y Proxy}}. Por ejemplo, el
patrón Adapter permite que interfaces incompatibles cooperen, y el
patrón Facade proporciona una interfaz simplificada para un conjunto
complejo de clases. De esta forma se logra organizar el sistema en capas
de abstracción o envolturas que ocultan la complejidad del subsistema.

\textbf{-Patrones de comportamiento:} Se centran en la interacción entre
objetos y la distribución de responsabilidades. Estos patrones optimizan
la forma en que los objetos se comunican y colaboran. Ejemplos
representativos incluyen \textbf{\emph{Observer, Strategy y Command}}.
Por ejemplo, Observer permite notificar a múltiples objetos ante cambios
en otro objeto observado, y Strategy define una familia de algoritmos
intercambiables dentro de un mismo objeto. En el contexto de C\#, los
eventos y delegados suelen implementar el patrón Observer (por ejemplo,
\textbf{\emph{INotifyPropertyChanged}} en WPF), mientras que mecanismos
como interfaces y funciones anónimas facilitan estrategias
intercambiables (Strategy).

Estos grupos de patrones provienen del catálogo clásico de (Gamma et
al.~1995) --los ``Gang of Four''-- que recopiló 23 patrones de diseño
ampliamente reconocidos. Desde entonces, dichos patrones se han
mantenido vigentes y se siguen enseñando como principios fundamentales
del diseño orientado a objetos. Ejemplos de patrones creacionales,
estructurales y de comportamiento: Los patrones creacionales más comunes
incluyen Factory Method, Abstract Factory, Builder, Prototype y
Singleton. Por ejemplo, el patrón Factory Method delega la creación de
objetos a subclases concretas (reduciendo dependencias directas), y
Abstract Factory agrupa fábricas de familias relacionadas. En C\#, la
clase StringBuilder implementa el patrón Builder al proporcionar pasos
seguros para construir cadenas complejas. En el ámbito estructural,
destacan Adapter, Bridge, Composite, Decorator, Facade, Flyweight y
Proxy. El patrón Composite permite tratar grupos de objetos como
elementos individuales, mientras que Proxy controla el acceso a un
objeto real. En cuanto a comportamiento, además de Observer, Strategy y
Command, existen Iterator, Mediator, Memento, State, Template Method,
Visitor, entre otros. Por ejemplo, Observer en C\# se ve en los eventos
de Windows Forms o WPF, y Strategy puede verse al pasar distintas
implementaciones de algoritmos (por ejemplo, clasificadores) a través de
interfaces.

\subsection{Patrones GOF comunes (patrones de diseño
clásicos)}\label{patrones-gof-comunes-patrones-de-diseuxf1o-cluxe1sicos}

El catálogo GOF sigue siendo una referencia obligada. A continuación se
destacan algunos patrones clave y su aplicación:

\textbf{-Factory Method (Patrón Factoría)}. Define una interfaz para
crear un objeto, pero permite que las subclases decidan qué clase
concreta instanciar. Esto desacopla el código cliente de las clases
específicas. Por ejemplo, en C\# un método factory puede devolver
distintas clases derivadas según parámetros de entrada. Figura: Diagrama
UML del patrón Factory Method. En el diagrama UML anterior se observa
cómo una clase creadora (Creator) delega la instanciación de Product a
métodos concretos (FactoryMethod) que devuelven objetos concretos
(ConcreteProduct). Este esquema facilita la extensión para nuevos tipos
de productos sin modificar el código cliente. En la plataforma .NET,
patrones similares se usan en abstracciones como DbProviderFactory o en
la fábrica de objetos de HttpClient.

\textbf{-Singleton (Patrón Único)}. Asegura que una clase tenga
exactamente una instancia y proporciona un punto de acceso global. En
C\#, esto se implementa mediante una clase que controla la creación de
la instancia (por ejemplo, usando propiedades estáticas y constructor
privado). El siguiente diagrama UML ilustra el patrón: Figura: Diagrama
UML del patrón Singleton. En C\# comúnmente se emplea el modificador
static y un constructor privado para lograrlo, o bien la propiedad Lazy
para inicialización perezosa, lo que garantiza creación única incluso en
entornos multihilo. El patrón Singleton se usa, por ejemplo, para
administrar conexiones compartidas (un único pool de conexiones a base
de datos) o configuraciones globales de la aplicación.

\textbf{Observer (Observador)}. Define una relación uno a muchos entre
objetos, de modo que al cambiar el estado de uno, se notifica
automáticamente a los demás suscritos. Esto implementa mecanismos de
suscripción/publicación. En C\#, el sistema de eventos (delegados
EventHandler) es una implementación típica de Observer.
(Refactoring.Guru, n.d.) describe este patrón como ``un mecanismo de
suscripción para notificar a varios objetos sobre cualquier evento''. Se
emplea, por ejemplo, en interfaces gráficas (un modelo notifica a varias
vistas) o en comunicaciones de mensajería interna.

\textbf{Strategy (Estrategia)}. Permite definir una familia de
algoritmos intercambiables y encapsularlos en clases separadas, de forma
que el objeto que los utiliza pueda cambiar de algoritmo en tiempo de
ejecución. Esto se logra típicamente mediante interfaces. En C\#, se
puede implementar pasando distintas implementaciones de una interfaz o
incluso funciones (delegados) al objeto que las ejecuta. (Soler, 2024)
menciona Strategy como patrón de comportamiento, e ilustra su uso para
algoritmos alternativos. Es útil, por ejemplo, en sistemas de pago donde
la estrategia de cálculo de comisión puede variar sin modificar el
cliente. Otros patrones como Decorator, Facade o Template Method también
se aplican frecuentemente en C\#. Por ejemplo, Decorator permite añadir
responsabilidades a objetos existentes al envolverlos, lo que puede
verse en clases que añaden funcionalidad adicional a colecciones o
flujos de datos.

\subsection{Ejemplos comunes en C\#}\label{ejemplos-comunes-en-c}

\subsubsection{Factory Method}\label{factory-method}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ DocumentFactory}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{abstract}\NormalTok{ IDocument }\FunctionTok{CreateDocument}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ PdfDocumentFactory }\OperatorTok{:}\NormalTok{ DocumentFactory}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{override}\NormalTok{ IDocument }\FunctionTok{CreateDocument}\OperatorTok{()} \OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{PdfDocument}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Singleton}\label{singleton}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ConfigurationManager}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ Lazy}\OperatorTok{\textless{}}\NormalTok{ConfigurationManager}\OperatorTok{\textgreater{}}\NormalTok{ instance }\OperatorTok{=} \KeywordTok{new}\OperatorTok{(()} \OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{ConfigurationManager}\OperatorTok{());}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ ConfigurationManager Instance }\OperatorTok{=\textgreater{}}\NormalTok{ instance}\OperatorTok{.}\FunctionTok{Value}\OperatorTok{;}
    \KeywordTok{private} \FunctionTok{ConfigurationManager}\OperatorTok{()} \OperatorTok{\{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Observer (eventos en C\#)}\label{observer-eventos-en-c}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ Stock}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{event}\NormalTok{ Action}\OperatorTok{\textless{}}\DataTypeTok{decimal}\OperatorTok{\textgreater{}}\NormalTok{ PriceChanged}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{decimal}\NormalTok{ price}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{decimal}\NormalTok{ Price}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ price}\OperatorTok{;}
        \KeywordTok{set} \OperatorTok{\{}
\NormalTok{            price }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{            PriceChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\NormalTok{price}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Strategy: ejemplo
completo}\label{strategy-ejemplo-completo}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ ICommissionStrategy}
\OperatorTok{\{}
    \DataTypeTok{decimal} \FunctionTok{CalculateCommission}\OperatorTok{(}\DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ StandardCommission }\OperatorTok{:}\NormalTok{ ICommissionStrategy}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{decimal} \FunctionTok{CalculateCommission}\OperatorTok{(}\DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ amount }\OperatorTok{*} \FloatTok{0.05m}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ PremiumCommission }\OperatorTok{:}\NormalTok{ ICommissionStrategy}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{decimal} \FunctionTok{CalculateCommission}\OperatorTok{(}\DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ amount }\OperatorTok{*} \FloatTok{0.025m}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ CorporateCommission }\OperatorTok{:}\NormalTok{ ICommissionStrategy}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{decimal} \FunctionTok{CalculateCommission}\OperatorTok{(}\DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{)} \OperatorTok{=\textgreater{}} \DecValTok{0}\NormalTok{m}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ TransactionProcessor}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ ICommissionStrategy \_strategy}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{TransactionProcessor}\OperatorTok{(}\NormalTok{ICommissionStrategy strategy}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_strategy }\OperatorTok{=}\NormalTok{ strategy}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Process}\OperatorTok{(}\DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ commission }\OperatorTok{=}\NormalTok{ \_strategy}\OperatorTok{.}\FunctionTok{CalculateCommission}\OperatorTok{(}\NormalTok{amount}\OperatorTok{);}
\NormalTok{        Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Processing $\{amount\} with commission: $\{commission\}"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\CommentTok{// Ejemplo de uso}
\DataTypeTok{var}\NormalTok{ processor }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TransactionProcessor}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PremiumCommission}\OperatorTok{());}
\NormalTok{processor}\OperatorTok{.}\FunctionTok{Process}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);} \CommentTok{// Output: Processing $1000 with commission: $25}
\end{Highlighting}
\end{Shaded}

\subsection{Patrones POSA (Pattern-Oriented Software Architecture) y
ejemplos
estructurales}\label{patrones-posa-pattern-oriented-software-architecture-y-ejemplos-estructurales}

Más allá de los patrones GOF, los patrones de arquitectura (o POSA,
Pattern-Oriented Software Architecture) abordan la estructura global del
sistema.

Un patrón arquitectónico es ``una solución general y reutilizable a un
problema común en la arquitectura de software dentro de un contexto
dado''. Tienen un alcance mayor que los de diseño de bajo nivel,
definiendo cómo se organizan los subsistemas de alto nivel. (Buschmann
et al., 1996) introdujeron patrones arquitectónicos como Microkernel,
Layers y Pipes and Filters, aplicables a sistemas complejos y
distribuidos.

\textbf{-Patrón en capas (Layered Architecture)}. Una de las
arquitecturas más comunes es la de múltiples capas. Por ejemplo, se
suele dividir el sistema en capa de presentación (interfaz), capa de
lógica de negocio, capa de servicios/aplicación y capa de acceso a
datos. El artículo de Ccori (Ccori Huaman, 2018) ilustra esto indicando
cuatro capas típicas: presentación, aplicación, negocio y persistencia.
Esta separación mejora la modularidad y facilita tareas como pruebas
unitarias, ya que cada capa puede desarrollarse y probarse de forma
independiente.

\textbf{-Modelo-Vista-Controlador (MVC)}. Es un patrón arquitectónico
que divide la aplicación en tres componentes: Modelo (datos y lógica),
Vista (presentación) y Controlador (gestión de la interacción del
usuario). Este desacoplamiento permite cambios independientes: por
ejemplo, modificar la interfaz de usuario (Vista) sin alterar la lógica
del Modelo. La figura siguiente ilustra el flujo básico de MVC: Figura:
Arquitectura Modelo-Vista-Controlador (MVC). En C\#, MVC se emplea
ampliamente en frameworks web (ASP.NET MVC) y de escritorio. Existen
variantes como MVVM en WPF que derivan de este concepto. El patrón MVC
mejora la mantenibilidad de aplicaciones interactivas al separar las
responsabilidades internas de la forma en que se presenta y acepta la
información. Otros patrones arquitectónicos comunes: Entre ellos figuran
Cliente-Servidor (un servidor atiende a múltiples clientes).

\textbf{-Maestro-Esclavo (un coordinador delega tareas a subsistemas) o
Pipeline (canal de procesamiento)}. El patrón pipe-filter (filtros y
tuberías) organiza el flujo de datos en etapas secuenciales (muy usado
en compiladores y pipelines de procesamiento de datos).

\textbf{-El patrón Broker (Agente intermediario)}. Gestiona la
comunicación entre componentes distribuidos, mediando peticiones (por
ejemplo, middleware de mensajería como RabbitMQ). En la era moderna
también es relevante mencionar la arquitectura de microservicios, que
puede considerarse un estilo donde cada servicio actúa como un
``cliente-servidor'' independiente comunicándose mediante APIs ligeras.

La investigación reciente destaca patrones específicos para
microservicios: uso de un ``registro de servicios'' (por ejemplo,
Netflix Eureka) para el descubrimiento dinámico de instancias, pasarela
API centralizada (API Gateway) y el uso de circuit breaker
(e.g.~Hystrix) para tolerancia a fallos.

\section{Microservicios y CQRS}\label{microservicios-y-cqrs}

La arquitectura de microservicios ha emergido como una solución efectiva
para abordar los desafíos de escalabilidad, mantenimiento y despliegue
en aplicaciones modernas distribuidas. A diferencia de las arquitecturas
monolíticas tradicionales, en las que toda la lógica de negocio se
encuentra contenida en una única unidad desplegable, los microservicios
promueven la descomposición del sistema en servicios independientes,
cada uno con su propia responsabilidad y base de datos. Esta separación
permite desarrollar, desplegar y escalar cada componente de forma
autónoma (Newman, 2015).

Uno de los retos principales en arquitecturas distribuidas es la
coherencia de los datos y el diseño de la comunicación entre servicios.
Para abordar estos problemas, se han propuesto diversos patrones
arquitectónicos, entre los que destaca CQRS (Command and Query
Responsibility Segregation). Este patrón sugiere una separación
explícita entre los modelos que procesan comandos (acciones que
modifican el estado del sistema) y aquellos que resuelven consultas
(lecturas del sistema), lo cual facilita el diseño de sistemas altamente
escalables y mantenibles (Fowler, 2011).

La combinación de CQRS con Event Sourcing ha demostrado ser
especialmente potente en sistemas distribuidos. Event Sourcing consiste
en almacenar el estado del sistema como una secuencia de eventos
inmutables, permitiendo reconstruir el estado a partir de estos eventos
y facilitando capacidades como el auditado, el debugging y la
replicación (Vernon, 2013). Aunque esta aproximación agrega complejidad,
ha sido utilizada con éxito en entornos de alta concurrencia y dominio
complejo.

Varios autores recomiendan una aplicación pragmática de CQRS y
microservicios. Fowler (2015) y Richardson (2018) advierten que no todos
los contextos se benefician igualmente de estos patrones, y que deben
aplicarse de forma gradual y guiada por el dominio del negocio. En
sistemas pequeños o con requisitos simples, una arquitectura monolítica
bien estructurada puede ser más efectiva (Richardson, 2018).

En entornos .NET, CQRS se implementa frecuentemente con el patrón
MediatR para desacoplar comandos y queries mediante un bus de mensajes
interno. Combinado con DDD (Domain-Driven Design), este enfoque permite
modelar las reglas del negocio con alta fidelidad y claridad (Lowy,
2013).

En resumen, la integración de microservicios y CQRS representa una
estrategia avanzada para el diseño de software moderno, pero requiere
una evaluación cuidadosa del contexto y la experiencia del equipo para
evitar una complejidad innecesaria.

\subsection{Beneficios y desafíos
actuales}\label{beneficios-y-desafuxedos-actuales}

En resumen, los patrones de diseño contribuyen a la calidad del software
en aspectos como reusabilidad, mantenibilidad y escalabilidad. Facilitan
la comunicación técnica (describiendo soluciones con nombres estándar) y
proveen una base común de conocimientos. Según (Freeman et al., 2004),
el uso de patrones no solo mejora la mantenibilidad, sino también la
comunicación entre desarrolladores mediante un lenguaje común.

Sin embargo, la aplicación de patrones no está exenta de retos.
(Chippagiri, 2025) advierte que implementar patrones de forma incorrecta
puede introducir anti-patrones (malas prácticas que imitan patrones
válidos) y complejidad innecesaria. Además, automatizar la detección de
patrones en código es difícil, lo que motiva la investigación en
herramientas basadas en inteligencia artificial para identificación de
patrones y anti-patrones. Por otro lado, los avances tecnológicos han
ampliado el alcance de los patrones tradicionales. Además de los
patrones clásicos, se estudian patrones emergentes adaptados a la
computación en nube, big data e inteligencia artificial. La revisión de
Chippagiri destaca patrones avanzados para sistemas basados en IA y
aprendizaje automático (como canalizaciones de procesamiento de datos,
optimización de hiperparámetros), así como patrones de seguridad
específicos (autenticación proxy, enmascarado de datos) para cumplir con
regulaciones actuales. Igualmente se reconocen patrones en arquitecturas
de nube: por ejemplo, caché distribuido y segmentación por
compartimentos (bulkhead) para mejorar rendimiento y tolerancia a fallos
en servicios distribuidos. En conclusión, el estado del arte muestra que
los patrones de diseño siguen siendo un pilar del desarrollo de software
de calidad, adaptándose a nuevos paradigmas. Su estudio actual no solo
reafirma los beneficios clásicos (comunicación, mantenimiento y
reutilización), sino que también aborda nuevas áreas (microservicios,
IA, seguridad) y reconoce desafíos asociados a su uso.

\newpage

\section{Conclusiones}\label{conclusiones}

En este informe se ha revisado en profundidad la definición,
clasificación y utilidad de los patrones de diseño en ingeniería de
software. Los patrones proporcionan un lenguaje común y un conjunto de
soluciones maduras para problemas recurrentes, lo que mejora la calidad
del diseño y acelera el desarrollo. La clasificación tradicional
(creacionales, estructurales y comportamentales) sigue siendo válida, y
los patrones GOF ejemplifican cada categoría. Además, los patrones de
arquitectura (como capas y MVC) orientan la estructura macro del
sistema. La investigación reciente indica que los patrones se aplican
ampliamente en dominios modernos (sistemas basados en IA, microservicios
y arquitecturas en nube). Sin embargo, también advierte sobre la
necesidad de aplicar los patrones con criterio, evitando anti-patrones y
aprovechando herramientas avanzadas de soporte. Para la práctica en C\#,
muchos patrones se reflejan en características del lenguaje: por
ejemplo, eventos/delegados implementan Observer, y clases como
StringBuilder ejemplifican Builder. Concluimos que el conocimiento
profundo de patrones de diseño es esencial para diseñar software robusto
y de calidad. Se recomienda a los desarrolladores y arquitectos
familiarizarse con estos patrones clásicos y emergentes, adaptándolos
según contexto, siempre basándose en evidencia y fuentes confiables.

La incorporación de patrones, tal como se expone en obras fundamentales
como las de (Gamma et al., 1995) y (Fowler, 2002), no solo permite
abordar problemas comunes de forma estructurada, sino que también
facilita el diseño sostenible de soluciones escalables.

\newpage

\newpage

\section{Referencias}\label{referencias}

\phantomsection\label{refs}
\begin{CSLReferences}{1}{0}
\bibitem[\citeproctext]{ref-buschmann1996pattern}
Buschmann, F., Meunier, R., Rohnert, H., Sommerlad, P., \& Stal, M.
(1996). \emph{Pattern-oriented software architecture, volume 1: A system
of patterns}. Wiley.

\bibitem[\citeproctext]{ref-ccori2018patrones}
Ccori Huaman, W. (2018, September 7). \emph{Los 10 patrones comunes de
arquitectura de software}.
\url{https://medium.com/@maniakhitoccori/los-10-patrones-comunes-de-arquitectura-de-software-d8b9047edf0b}

\bibitem[\citeproctext]{ref-chippagiri2025comprehensive}
Chippagiri, S. (2025). A comprehensive review of software design
patterns: Applications and future direction. \emph{The Review of
Contemporary Scientific and Academic Studies}, \emph{5}(2), 1--12.
\url{https://doi.org/10.55454/rcsas.5.02.2025.001}

\bibitem[\citeproctext]{ref-fowler2002patterns}
Fowler, M. (2002). \emph{Patterns of enterprise application
architecture}. Addison-Wesley.

\bibitem[\citeproctext]{ref-fowler2011cqrs}
Fowler, M. (2011). \emph{CQRS}.
\url{https://martinfowler.com/bliki/CQRS.html}

\bibitem[\citeproctext]{ref-freeman2004head}
Freeman, E., Robson, E., Bates, B., \& Sierra, K. (2004). \emph{Head
first design patterns}. O'Reilly Media.

\bibitem[\citeproctext]{ref-gamma1995design}
Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1995). \emph{Design
patterns: Elements of reusable object-oriented software}.
Addison-Wesley.

\bibitem[\citeproctext]{ref-lowy2013implementing}
Lowy, U. (2013). \emph{Implementing domain-driven design}. Blue Spire
Consulting.

\bibitem[\citeproctext]{ref-newman2015building}
Newman, S. (2015). \emph{Building microservices}. O'Reilly Media.

\bibitem[\citeproctext]{ref-refactoringguru_nodate}
Refactoring.Guru. (n.d., n.d.). \emph{Patrones de diseño (design
patterns)}. \url{https://refactoring.guru/es/design-patterns}

\bibitem[\citeproctext]{ref-richardson2018microservices}
Richardson, C. (2018). \emph{Microservices patterns: With examples in
java}. Manning Publications.

\bibitem[\citeproctext]{ref-soler2024patrones}
Soler, D. (2024, May 10). \emph{¿Qué son los patrones de diseño de
software?}
\url{https://keepcoding.io/blog/patrones-de-diseno-de-software/}

\bibitem[\citeproctext]{ref-vernon2013implementing}
Vernon, V. (2013). \emph{Implementing domain-driven design}.
Addison-Wesley.

\end{CSLReferences}




\end{document}
